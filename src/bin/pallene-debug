#!/usr/bin/env lua

local argparse = require "argparse"

local opts
do
    local p = argparse("pallene-debug", "Pallene debugger script for call-stack backtrace")

    p:argument("lua_script", "Lua file to debug with Pallene module")
    p:argument("args",       "Arguments passed to Lua script")       :args("*")

    opts = p:parse()
end

local fn, err = loadfile(opts.lua_script)

-- Was loading and parsing the file successful?
if not fn then
    io.stderr:write("pallene-debug: "..err.."\n")
    os.exit(1)
end

-- Supress I/O.
local original_print = print
local original_io_write = io.write

print    = function() end
io.write = function() end

-- Run the script initially so that we can figure out whether
-- we have Pallene modules that is compiled with `--use-traceback` flag.
local _, _ = pcall(fn)

-- Restore I/O.
print    = original_print
io.write = original_io_write

-- We need the traceback fn.
if not pallene_tracer_debug_traceback then
    io.stderr:write("pallene-debug: could not find debug traceback fn: Make sure you include Pallene modules which are compiled with `--use-traceback` flag.\n")
    os.exit(1)
end

-- Add a wrapper function.
local function wrapper()
    fn(table.unpack(opts.args))
end

-- Moment of truth.
xpcall(wrapper, pallene_tracer_debug_traceback)
